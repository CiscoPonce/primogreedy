import os
import re
import requests
import yfinance as yf
from dotenv import load_dotenv
from src.finance_tools import check_financial_health
from src.email_utils import send_email_report
from src.global_router import MARKET_CONFIG, normalize_ticker, get_official_filing_link

load_dotenv()

# --- 1. BRAVE SEARCH DISCOVERY ENGINE ---
def brave_search_scout(query):
    """
    Uses Brave API to find web discussions about stocks.
    Returns the combined text of titles and descriptions.
    """
    api_key = os.getenv("BRAVE_API_KEY")
    if not api_key:
        print("‚ö†Ô∏è Brave API Key missing. Returning empty.")
        return ""

    url = "https://api.search.brave.com/res/v1/web/search"
    headers = {"X-Subscription-Token": api_key}
    
    # We look for recent discussions (past month) to get fresh ideas
    params = {"q": query, "count": 10, "freshness": "pm"} 
    
    try:
        response = requests.get(url, headers=headers, params=params)
        data = response.json()
        
        # Combine all text into one big blob for the regex hunter
        combined_text = ""
        results = data.get("web", {}).get("results", [])
        for r in results:
            combined_text += f"{r['title']} {r['description']} "
            
        return combined_text
    except Exception as e:
        print(f"‚ùå Brave Search Error: {e}")
        return ""

def extract_tickers(text, region):
    """
    Uses Regex to find stock patterns like $ABCD, (ABCD), (LON: ABC).
    """
    found_tickers = set()
    
    # 1. Regex for CashTags: $AAPL
    cashtags = re.findall(r'\$([A-Za-z]{2,5})', text)
    found_tickers.update([t.upper() for t in cashtags])

    # 2. üü¢ NUEVO: Regex for Parentheses: (AAPL) o (TSLA)
    # Evitamos falsos positivos comunes de 2 letras como (US), (UK), (EU)
    parentheses = re.findall(r'\(([A-Z]{3,5})\)', text)
    found_tickers.update(parentheses)

    # 3. Regional Specifics
    if region == "UK":
        uk_tags = re.findall(r'LON:\s?([A-Za-z]{2,5})', text)
        found_tickers.update([t.upper() for t in uk_tags])
    elif region == "CANADA":
        ca_tags = re.findall(r'TSX:\s?([A-Za-z]{2,5})', text)
        found_tickers.update([t.upper() for t in ca_tags])

    # 4. Clean and Normalize
    normalized = []
    suffix = MARKET_CONFIG[region]['suffix']
    
    for t in found_tickers:
        clean_t = t.strip().upper()
        # Blacklist de palabras comunes que parecen tickers
        if clean_t in ["IPO", "CEO", "YTD", "USD", "GBP", "EUR", "ETF", "EPS", "FYI", "AGM"]:
            continue
            
        if suffix and not clean_t.endswith(suffix):
            clean_t = f"{clean_t}{suffix}"
            
        normalized.append(clean_t)
        
    return list(set(normalized))

# --- 2. MAIN EXECUTION LOOP ---
def run_global_hunt():
    print("üåç Starting Agentic Global Scout (Brave Powered)...")
    report_html = "<h1>üåç Daily Agentic Scout Report</h1>"
    report_html += "<p><i>Generated by scraping real-time market discussions via Brave Search.</i></p>"
    
    gems_found = False
    
    # Specific Search Queries for each region
    search_queries = {
        "USA": "undervalued microcap stocks reddit 2026 buy list",
        "UK": "best aim stocks to buy 2026 undervalued ukinvesting",
        "CANADA": "tsx venture deep value stocks mining reddit",
        "AUSTRALIA": "asx small cap gems hotcopper undervalued"
    }

    for region, config in MARKET_CONFIG.items():
        query = search_queries.get(region)
        print(f"üïµÔ∏è Scout Searching {region}: '{query}'")
        
        # A. DISCOVER (Brave)
        raw_text = brave_search_scout(query)
        candidates = extract_tickers(raw_text, region)
        
        print(f"   ‚Ü≥ Found {len(candidates)} potential tickers: {candidates}")
        
        region_gems = []
        for ticker in candidates:
            try:
                # B. ANALYZE (Graham/Buffett Logic)
                # We do a quick check to ensure ticker is valid first
                stock = yf.Ticker(ticker)
                price = stock.info.get('currentPrice')
                
                if not price: 
                    continue # Invalid ticker found by Regex

               # The Value Filter
                health = check_financial_health(ticker)
                
                if health['status'] == "PASS" or health.get('metrics', {}).get('margin_of_safety', 'N/A') != "N/A":
                    link = get_official_filing_link(ticker, region)
                    gems_found = True
                    
                    safety = health['metrics'].get('margin_of_safety', 'N/A')
                    color = "green" if "%" in str(safety) and "-" not in str(safety) else "black"
                    
                    # üü¢ COSMETIC FIX: Smart Price Formatting
                    raw_price = stock.info.get('currentPrice', 0)
                    currency = stock.info.get('currency', 'USD')
                    
                    if region == "UK" and raw_price > 50: # Assuming penny stocks
                        display_price = f"¬£{raw_price/100:.2f}"
                    else:
                        display_price = f"{raw_price} {currency}"

                    region_gems.append(f"""
                        <li style="margin-bottom: 10px;">
                            <b>{ticker}</b> ({stock.info.get('shortName', 'Unknown')})<br>
                            Price: {display_price}<br> 
                            Verdict: {health['reason']}<br>
                            Safety Margin: <span style="color:{color}; font-weight:bold;">{safety}</span><br>
                            <a href="{link}">Verify at {config['gov_source']}</a>
                        </li>
                    """)
            except Exception as e:
                # Common to have errors with random regex tickers
                continue
        
        if region_gems:
            report_html += f"<h2>üìç {region} Discovery</h2><ul>" + "".join(region_gems) + "</ul>"
        else:
            report_html += f"<h2>üìç {region}</h2><p>Scouted {len(candidates)} tickers, but none met Graham's strict criteria.</p>"

    
# --- EMAIL DISPATCH ---
    # We define a list of user profiles to ensure everyone gets a copy 
    # using their own API key (High Reliability).
    
    users = [
        {"name": "Cisco", "email": os.getenv("EMAIL_CISCO"), "key": os.getenv("RESEND_API_KEY_CISCO")},
        {"name": "Raul", "email": os.getenv("EMAIL_RAUL"), "key": os.getenv("RESEND_API_KEY_RAUL")},
        {"name": "David", "email": os.getenv("EMAIL_DAVID"), "key": os.getenv("RESEND_API_KEY_DAVID")} # üü¢ Welcome David!
    ]

    print(f"üìß Preparing Dispatch for {len(users)} agents...")

    # We iterate through users. If they have credentials, we send the email.
    for user in users:
        if user["email"] and user["key"]:
            print(f"   ‚Ü≥ Sending to {user['name']}...")
            try:
                # We assume send_email_report takes (subject, html, recipient, api_key)
                # If your current function only takes (subject, html, recipient), 
                # we might need to verify src/email_utils.py. 
                # Assuming standard usage based on previous setup:
                send_email_report(
                    subject="Agentic Scout Report", 
                    html_content=report_html, 
                    recipient=user["email"],
                    api_key=user["key"] # üëà Ensuring we use HIS key
                )
            except Exception as e:
                print(f"   ‚ùå Failed to send to {user['name']}: {e}")
        else:
            print(f"   ‚ö†Ô∏è Skipping {user['name']} (Missing Credentials)")

if __name__ == "__main__":
    run_global_hunt()